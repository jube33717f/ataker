{"ast":null,"code":"var _jsxFileName = \"/Users/jubi/fullStack/groupProject/0322/xyz.frontend/src/hoc/validationHoc.js\";\nimport React, { Component } from \"react\";\nimport { validators } from \"./validator\";\nimport { withRouter } from \"react-router-dom\"; // TODO @SONIA\n\nexport default ((WrappedComponent, requiredFields) => {\n  //fieldName, validator) {\n  class ValidationHoc extends Component {\n    constructor(props) {\n      super(props);\n\n      this.setInitialData = data => {\n        //cannot be  setInitialData(data) {}\n        this.setState({\n          values: { ...this.state.values,\n            ...data\n          }\n        });\n      };\n\n      this.onChange = async event => {\n        //这里不需要再加async/await。为啥？？   \n        event.persist(); //不加它的话会有Warning: This synthetic event is reused for performance reasons....\n\n        let {\n          name,\n          value\n        } = event.target;\n\n        if (!name) {\n          name = event.target.getAttribute(\"name\");\n          value = event.target.getAttribute(\"value\");\n        }\n\n        await this.setState({\n          values: { ...this.state.values,\n            [name]: value\n          }\n        }); // added\n\n        if (Object.keys(this.state.errors).length > 0) {\n          this.checkValidationErrors(event);\n        }\n      };\n\n      this.checkValidationErrors = event => {\n        let validationErrors = {};\n\n        if (event) {\n          let {\n            name,\n            value\n          } = event.target;\n\n          if (!name) {\n            name = event.target.getAttribute(\"name\");\n            value = event.target.getAttribute(\"value\");\n          }\n\n          const validator = validators[name];\n\n          if (validator && typeof validator.func === \"function\") {\n            if (!validator.func(this.state.values[name])) {\n              validationErrors[name] = validator.msg;\n            } else {\n              validationErrors[name] = \"\"; //修复违背validator逻辑的用户输入\n            }\n          } else {\n            //如果只在if (!validator.func(this.state.values[event.target.name])) 的后面加上这个else，不能让第一次出现requiredfields的错误在用户第二次输入时修复\n            validationErrors[name] = \"\"; // code update:\n\n            if (requiredFields && requiredFields.includes(name) && !this.state.values[name]) {\n              validationErrors[name] = \"Please complete this required field\";\n            }\n          }\n        } else {\n          Object.keys(this.state.values).forEach(field => {\n            const validator = validators[field];\n\n            if (validator && typeof validator.func === \"function\") {\n              if (!validator.func(this.state.values[field])) {\n                validationErrors[field] = validator.msg;\n              } else {\n                validationErrors[field] = \"\";\n              }\n            }\n          });\n        }\n\n        this.setState({\n          errors: { ...this.state.errors,\n            ...validationErrors\n          }\n        });\n      };\n\n      this.okToSubmit = async fieldsToCheck => {\n        await this.checkValidationErrors();\n\n        if (Array.isArray(requiredFields)) {\n          let requiredFieldErrors = {};\n          requiredFields.forEach(field => {\n            // console.log(this.state.values[field])\n            if (!this.state.values[field]) {\n              if (!fieldsToCheck || fieldsToCheck && fieldsToCheck.includes(field)) {\n                //对分页表单来讲，不需要把后面的页数的必填提示提早设置好\n                requiredFieldErrors[field] = 'Please complete this required field';\n              }\n            }\n          });\n          await this.setState({\n            errors: { ...this.state.errors,\n              ...requiredFieldErrors\n            }\n          });\n        }\n\n        let inputValid = true;\n\n        if (Object.keys(this.state.errors)) {\n          inputValid = Object.keys(this.state.errors).every((field, index) => {\n            // should be arrow function if use this inside\n            if (fieldsToCheck) {\n              return fieldsToCheck.every(field => this.state.errors[field] === \"\" || !this.state.errors[field]);\n            } else {\n              return this.state.errors[field] === \"\";\n            }\n          });\n        }\n\n        if (!inputValid) {\n          await this.setState({\n            errMsg: \"Please follow instructions above to complete the form!\"\n          });\n        }\n\n        return inputValid;\n      };\n\n      this.state = {\n        errors: {},\n        values: {},\n        errMsg: ''\n      };\n    }\n\n    componentDidMount() {\n      if (this.props.location.state) {\n        //TypeError: Cannot read property 'state' of undefined. 所以这里要在hoc外面自己包一层withrouter\n        this.setState({\n          values: { ...this.props.location.state.signupValues\n          }\n        });\n      }\n    }\n\n    render() {\n      const hocProps = {\n        onChange: this.onChange,\n        okToSubmit: this.okToSubmit,\n        checkValidationErrors: this.checkValidationErrors,\n        setInitialData: this.setInitialData,\n        ...this.state // values: this.state.values,errors: this.state.errors //这样可读性反而好一点\n\n      };\n      return React.createElement(WrappedComponent, Object.assign({}, hocProps, this.props, {\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 153\n        },\n        __self: this\n      }));\n    }\n\n  }\n\n  return withRouter(ValidationHoc); //TypeError: Cannot read property 'state' of undefined (见location in componentdidmount)\n});","map":{"version":3,"sources":["/Users/jubi/fullStack/groupProject/0322/xyz.frontend/src/hoc/validationHoc.js"],"names":["React","Component","validators","withRouter","WrappedComponent","requiredFields","ValidationHoc","constructor","props","setInitialData","data","setState","values","state","onChange","event","persist","name","value","target","getAttribute","Object","keys","errors","length","checkValidationErrors","validationErrors","validator","func","msg","includes","forEach","field","okToSubmit","fieldsToCheck","Array","isArray","requiredFieldErrors","inputValid","every","index","errMsg","componentDidMount","location","signupValues","render","hocProps"],"mappings":"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","sourcesContent":["import React, { Component } from \"react\";\nimport { validators } from \"./validator\";\nimport { withRouter } from \"react-router-dom\"\n// TODO @SONIA\n\nexport default (WrappedComponent, requiredFields) => {\n  //fieldName, validator) {\n  class ValidationHoc extends Component {\n    constructor(props) {\n      super(props);\n      this.state = {\n        errors: {},\n        values: {},\n        errMsg: '',\n      };\n    }\n    componentDidMount() {\n      if (this.props.location.state) { //TypeError: Cannot read property 'state' of undefined. 所以这里要在hoc外面自己包一层withrouter\n        this.setState({ values: { ...this.props.location.state.signupValues } })\n      }\n    }\n\n    setInitialData = (data) => { //cannot be  setInitialData(data) {}\n      this.setState({\n        values: {\n          ...this.state.values,\n          ...data\n        }\n      });\n    }\n\n    onChange = async (event) => {//这里不需要再加async/await。为啥？？   \n      event.persist();//不加它的话会有Warning: This synthetic event is reused for performance reasons....\n      let { name, value } = event.target;\n      if (!name) {\n        name = event.target.getAttribute(\"name\");\n        value = event.target.getAttribute(\"value\");\n      }\n      await this.setState({\n        values: {\n          ...this.state.values,\n          [name]: value\n        }\n      });\n      // added\n      if (Object.keys(this.state.errors).length > 0) {\n        this.checkValidationErrors(event);\n      }\n    };\n\n    checkValidationErrors = (event) => {\n\n      let validationErrors = {};\n      if (event) {\n        let { name, value } = event.target;\n        if (!name) {\n          name = event.target.getAttribute(\"name\");\n          value = event.target.getAttribute(\"value\");\n        }\n\n        const validator = validators[name];\n\n        if (validator && typeof validator.func === \"function\") {\n          if (!validator.func(this.state.values[name])) {\n            validationErrors[name] = validator.msg;\n          } else {\n            validationErrors[name] = \"\"; //修复违背validator逻辑的用户输入\n          }\n        }\n        else {\n          //如果只在if (!validator.func(this.state.values[event.target.name])) 的后面加上这个else，不能让第一次出现requiredfields的错误在用户第二次输入时修复\n          validationErrors[name] = \"\";\n          // code update:\n          if (requiredFields && requiredFields.includes(name) && !this.state.values[name]) {\n            validationErrors[name] = \"Please complete this required field\";\n          }\n\n        }\n      }\n      else {\n        Object.keys(this.state.values).forEach(\n          field => {\n            const validator = validators[field];\n            if (validator && typeof validator.func === \"function\") {\n              if (!validator.func(this.state.values[field])) {\n                validationErrors[field] = validator.msg;\n              } else {\n                validationErrors[field] = \"\";\n              }\n            }\n          }\n        );\n      }\n\n      this.setState({\n        errors: {\n          ...this.state.errors,\n          ...validationErrors\n        }\n      });\n    }\n\n    /// 被包裹的组件在submit表单的时候调用，确保所有条目没有任何错误\n    // fieldsToCheck是提交分页表单的每一页时传递的数组，包含了当前页面的fields\n    okToSubmit = async (fieldsToCheck) => {\n\n      await this.checkValidationErrors();\n      \n      if (Array.isArray(requiredFields)) {\n        let requiredFieldErrors = {};\n        requiredFields.forEach((field) => {\n          // console.log(this.state.values[field])\n          if (!(this.state.values[field])) {\n            if (!fieldsToCheck || (fieldsToCheck && fieldsToCheck.includes(field))) { //对分页表单来讲，不需要把后面的页数的必填提示提早设置好\n              requiredFieldErrors[field] = 'Please complete this required field'\n            }\n          }\n        })\n        await this.setState({ errors: { ...this.state.errors, ...requiredFieldErrors } })\n      }\n\n\n      let inputValid = true;\n      if (Object.keys(this.state.errors)) {\n        inputValid = Object.keys(this.state.errors).every((field, index) => {\n          // should be arrow function if use this inside\n          if (fieldsToCheck) {\n            return fieldsToCheck.every(field => this.state.errors[field] === \"\" || !this.state.errors[field])\n          }\n          else { return this.state.errors[field] === \"\"; }\n        });\n      }\n      if (!inputValid) {\n        await this.setState({\n          errMsg:\n            \"Please follow instructions above to complete the form!\"\n        });\n      }\n\n      return inputValid;\n    };\n\n\n    render() {\n      const hocProps = {\n        onChange: this.onChange,\n        okToSubmit: this.okToSubmit,\n        checkValidationErrors: this.checkValidationErrors,\n        setInitialData: this.setInitialData,\n        ...this.state,\n        // values: this.state.values,errors: this.state.errors //这样可读性反而好一点\n      };\n      return <WrappedComponent {...hocProps} {...this.props} />;\n    }\n  }\n  return withRouter(ValidationHoc); //TypeError: Cannot read property 'state' of undefined (见location in componentdidmount)\n};\n"]},"metadata":{},"sourceType":"module"}