{"ast":null,"code":"var _jsxFileName = \"/Users/jubi/fullStack/groupProject/0322/xyz.frontend/src/hoc/validationHoc.js\";\nimport React, { Component } from \"react\";\nimport { validators } from \"./validator\";\nimport { withRouter } from \"react-router-dom\"; // TODO @SONIA\n\nexport default ((WrappedComponent, requiredFields) => {\n  class ValidationHoc extends Component {\n    constructor(props) {\n      super(props);\n\n      this.setHocData = data => {\n        this.setState({\n          values: { ...this.state.values,\n            ...data\n          }\n        });\n      };\n\n      this.onChange = async event => {\n        event.persist();\n        let {\n          name,\n          value\n        } = event.target;\n        await this.setState({\n          values: { ...this.state.values,\n            [name]: value\n          }\n        });\n\n        if (Object.keys(this.state.errors).length > 0) {\n          this.checkValidationErrors(event);\n        }\n      };\n\n      this.checkValidationErrors = event => {\n        let validationErrors = {};\n\n        if (event) {\n          let {\n            name,\n            value\n          } = event.target;\n          const validator = validators[name];\n\n          if (validator && typeof validator.func === \"function\") {\n            if (!validator.func(this.state.values[name])) {\n              validationErrors[name] = validator.msg;\n            } else {\n              validationErrors[name] = \"\"; //修复违背validator逻辑的用户输入\n            }\n          } else {\n            //如果只在if (!validator.func(this.state.values[event.target.name])) 的后面加上这个else，不能让第一次出现requiredfields的错误在用户第二次输入时修复\n            validationErrors[name] = \"\";\n\n            if (requiredFields && requiredFields.includes(name) && !this.state.values[name]) {\n              validationErrors[name] = \"Please complete this required field\";\n            }\n          }\n        } else {\n          Object.keys(this.state.values).forEach(field => {\n            const validator = validators[field];\n\n            if (validator && typeof validator.func === \"function\") {\n              if (!validator.func(this.state.values[field])) {\n                validationErrors[field] = validator.msg;\n              } else {\n                validationErrors[field] = \"\";\n              }\n            }\n          });\n        }\n\n        let requiredFieldErrors = {};\n\n        if (Array.isArray(requiredFields)) {\n          requiredFields.forEach(field => {\n            if (!this.state.values[field]) {\n              requiredFieldErrors[field] = 'Please complete this required field';\n            }\n          });\n        }\n\n        this.setState({\n          errors: { ...this.state.errors,\n            ...validationErrors,\n            ...requiredFieldErrors\n          }\n        });\n      };\n\n      this.okToSubmit = async () => {\n        await this.checkValidationErrors();\n        let inputValid = true;\n\n        if (Object.keys(this.state.errors)) {\n          inputValid = Object.keys(this.state.errors).every((field, index) => {\n            return this.state.errors[field] === \"\";\n          });\n        }\n\n        return inputValid;\n      };\n\n      this.state = {\n        errors: {},\n        values: {},\n        errMsg: ''\n      };\n    }\n\n    render() {\n      const hocProps = {\n        onChange: this.onChange,\n        okToSubmit: this.okToSubmit,\n        checkValidationErrors: this.checkValidationErrors,\n        setHocData: this.setHocData,\n        values: this.state.values,\n        errors: this.state.errors\n      };\n      return React.createElement(WrappedComponent, Object.assign({}, hocProps, this.props, {\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 120\n        },\n        __self: this\n      }));\n    }\n\n  }\n\n  return withRouter(ValidationHoc);\n});","map":{"version":3,"sources":["/Users/jubi/fullStack/groupProject/0322/xyz.frontend/src/hoc/validationHoc.js"],"names":["React","Component","validators","withRouter","WrappedComponent","requiredFields","ValidationHoc","constructor","props","setHocData","data","setState","values","state","onChange","event","persist","name","value","target","Object","keys","errors","length","checkValidationErrors","validationErrors","validator","func","msg","includes","forEach","field","requiredFieldErrors","Array","isArray","okToSubmit","inputValid","every","index","errMsg","render","hocProps"],"mappings":"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","sourcesContent":["import React, { Component } from \"react\";\nimport { validators } from \"./validator\";\nimport { withRouter } from \"react-router-dom\"\n// TODO @SONIA\n\nexport default (WrappedComponent, requiredFields) => {\n\n  class ValidationHoc extends Component {\n    constructor(props) {\n      super(props);\n      this.state = {\n        errors: {},\n        values: {},\n        errMsg: '',\n      };\n    }\n\n    setHocData = (data) => {\n      this.setState({\n        values: {\n          ...this.state.values,\n          ...data\n        }\n      });\n    }\n\n    onChange = async (event) => {\n      event.persist();\n      let { name, value } = event.target;\n      await this.setState({\n        values: {\n          ...this.state.values,\n          [name]: value\n        }\n      });\n      if (Object.keys(this.state.errors).length > 0) {\n        this.checkValidationErrors(event);\n      }\n    };\n\n    // check validators of all elements in this.state.values and set errors[field]\n    checkValidationErrors = (event) => {\n\n      let validationErrors = {};\n      if (event) {\n        let { name, value } = event.target;\n        const validator = validators[name];\n\n        if (validator && typeof validator.func === \"function\") {\n          if (!validator.func(this.state.values[name])) {\n            validationErrors[name] = validator.msg;\n          } else {\n            validationErrors[name] = \"\"; //修复违背validator逻辑的用户输入\n          }\n        }\n        else {\n          //如果只在if (!validator.func(this.state.values[event.target.name])) 的后面加上这个else，不能让第一次出现requiredfields的错误在用户第二次输入时修复\n          validationErrors[name] = \"\";\n          if (requiredFields && requiredFields.includes(name) && !this.state.values[name]) {\n            validationErrors[name] = \"Please complete this required field\";\n          }\n        }\n      }\n      else {\n        Object.keys(this.state.values).forEach(\n          field => {\n            const validator = validators[field];\n            if (validator && typeof validator.func === \"function\") {\n              if (!validator.func(this.state.values[field])) {\n                validationErrors[field] = validator.msg;\n              } else {\n                validationErrors[field] = \"\";\n              }\n            }\n          }\n        );\n      }\n\n      let requiredFieldErrors = {};\n      if (Array.isArray(requiredFields)) {\n        requiredFields.forEach((field) => {\n          if (!(this.state.values[field])) {\n            requiredFieldErrors[field] = 'Please complete this required field'\n          }\n        })\n      }\n\n      this.setState({\n        errors: {\n          ...this.state.errors,\n          ...validationErrors,\n          ...requiredFieldErrors\n        }\n      });\n    }\n\n    /// 被包裹的组件在submit表单的时候调用，确保所有条目没有任何错误\n    // fieldsToCheck是提交分页表单的每一页时传递的数组，包含了当前页面的fields\n    okToSubmit = async () => {\n      await this.checkValidationErrors();\n      let inputValid = true;\n      if (Object.keys(this.state.errors)) {\n        inputValid = Object.keys(this.state.errors).every((field, index) => {\n          return this.state.errors[field] === \"\";\n        });\n      }\n      return inputValid;\n    };\n\n\n    render() {\n      const hocProps = {\n        onChange: this.onChange,\n        okToSubmit: this.okToSubmit,\n        checkValidationErrors: this.checkValidationErrors,\n        setHocData: this.setHocData,\n        values: this.state.values,\n        errors: this.state.errors\n      };\n      return <WrappedComponent {...hocProps} {...this.props} />;\n    }\n  }\n\n  return withRouter(ValidationHoc);\n};\n"]},"metadata":{},"sourceType":"module"}