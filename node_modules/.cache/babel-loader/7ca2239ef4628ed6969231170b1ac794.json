{"ast":null,"code":"var debug = require('debug')('koa-router');\n\nvar pathToRegExp = require('path-to-regexp');\n\nvar uri = require('urijs');\n\nmodule.exports = Layer;\n/**\n * Initialize a new routing Layer with given `method`, `path`, and `middleware`.\n *\n * @param {String|RegExp} path Path string or regular expression.\n * @param {Array} methods Array of HTTP verbs.\n * @param {Array} middleware Layer callback/middleware or series of.\n * @param {Object=} opts\n * @param {String=} opts.name route name\n * @param {String=} opts.sensitive case sensitive (default: false)\n * @param {String=} opts.strict require the trailing slash (default: false)\n * @returns {Layer}\n * @private\n */\n\nfunction Layer(path, methods, middleware, opts) {\n  this.opts = opts || {};\n  this.name = this.opts.name || null;\n  this.methods = [];\n  this.paramNames = [];\n  this.stack = Array.isArray(middleware) ? middleware : [middleware];\n\n  for (var i = 0; i < methods.length; i++) {\n    var l = this.methods.push(methods[i].toUpperCase());\n\n    if (this.methods[l - 1] === 'GET') {\n      this.methods.unshift('HEAD');\n    }\n  } // ensure middleware is a function\n\n\n  for (var i = 0; i < this.stack.length; i++) {\n    var fn = this.stack[i];\n    var type = typeof fn;\n\n    if (type !== 'function') {\n      throw new Error(methods.toString() + \" `\" + (this.opts.name || path) + \"`: `middleware` \" + \"must be a function, not `\" + type + \"`\");\n    }\n  }\n\n  this.path = path;\n  this.regexp = pathToRegExp(path, this.paramNames, this.opts);\n  debug('defined route %s %s', this.methods, this.opts.prefix + this.path);\n}\n\n;\n/**\n * Returns whether request `path` matches route.\n *\n * @param {String} path\n * @returns {Boolean}\n * @private\n */\n\nLayer.prototype.match = function (path) {\n  return this.regexp.test(path);\n};\n/**\n * Returns map of URL parameters for given `path` and `paramNames`.\n *\n * @param {String} path\n * @param {Array.<String>} captures\n * @param {Object=} existingParams\n * @returns {Object}\n * @private\n */\n\n\nLayer.prototype.params = function (path, captures, existingParams) {\n  var params = existingParams || {};\n\n  for (var len = captures.length, i = 0; i < len; i++) {\n    if (this.paramNames[i]) {\n      var c = captures[i];\n      params[this.paramNames[i].name] = c ? safeDecodeURIComponent(c) : c;\n    }\n  }\n\n  return params;\n};\n/**\n * Returns array of regexp url path captures.\n *\n * @param {String} path\n * @returns {Array.<String>}\n * @private\n */\n\n\nLayer.prototype.captures = function (path) {\n  if (this.opts.ignoreCaptures) return [];\n  return path.match(this.regexp).slice(1);\n};\n/**\n * Generate URL for route using given `params`.\n *\n * @example\n *\n * ```javascript\n * const route = new Layer('/users/:id', ['GET'], fn);\n *\n * route.url({ id: 123 }); // => \"/users/123\"\n * ```\n *\n * @param {Object} params url parameters\n * @returns {String}\n * @private\n */\n\n\nLayer.prototype.url = function (params, options) {\n  var args = params;\n  var url = this.path.replace(/\\(\\.\\*\\)/g, '');\n  var toPath = pathToRegExp.compile(url);\n  var replaced;\n\n  if (typeof params != 'object') {\n    args = Array.prototype.slice.call(arguments);\n\n    if (typeof args[args.length - 1] == 'object') {\n      options = args[args.length - 1];\n      args = args.slice(0, args.length - 1);\n    }\n  }\n\n  var tokens = pathToRegExp.parse(url);\n  var replace = {};\n\n  if (args instanceof Array) {\n    for (var len = tokens.length, i = 0, j = 0; i < len; i++) {\n      if (tokens[i].name) replace[tokens[i].name] = args[j++];\n    }\n  } else if (tokens.some(token => token.name)) {\n    replace = params;\n  } else {\n    options = params;\n  }\n\n  replaced = toPath(replace);\n\n  if (options && options.query) {\n    var replaced = new uri(replaced);\n    replaced.search(options.query);\n    return replaced.toString();\n  }\n\n  return replaced;\n};\n/**\n * Run validations on route named parameters.\n *\n * @example\n *\n * ```javascript\n * router\n *   .param('user', function (id, ctx, next) {\n *     ctx.user = users[id];\n *     if (!user) return ctx.status = 404;\n *     next();\n *   })\n *   .get('/users/:user', function (ctx, next) {\n *     ctx.body = ctx.user;\n *   });\n * ```\n *\n * @param {String} param\n * @param {Function} middleware\n * @returns {Layer}\n * @private\n */\n\n\nLayer.prototype.param = function (param, fn) {\n  var stack = this.stack;\n  var params = this.paramNames;\n\n  var middleware = function (ctx, next) {\n    return fn.call(this, ctx.params[param], ctx, next);\n  };\n\n  middleware.param = param;\n  var names = params.map(function (p) {\n    return p.name;\n  });\n  var x = names.indexOf(param);\n\n  if (x > -1) {\n    // iterate through the stack, to figure out where to place the handler fn\n    stack.some(function (fn, i) {\n      // param handlers are always first, so when we find an fn w/o a param property, stop here\n      // if the param handler at this part of the stack comes after the one we are adding, stop here\n      if (!fn.param || names.indexOf(fn.param) > x) {\n        // inject this param handler right before the current item\n        stack.splice(i, 0, middleware);\n        return true; // then break the loop\n      }\n    });\n  }\n\n  return this;\n};\n/**\n * Prefix route path.\n *\n * @param {String} prefix\n * @returns {Layer}\n * @private\n */\n\n\nLayer.prototype.setPrefix = function (prefix) {\n  if (this.path) {\n    this.path = prefix + this.path;\n    this.paramNames = [];\n    this.regexp = pathToRegExp(this.path, this.paramNames, this.opts);\n  }\n\n  return this;\n};\n/**\n * Safe decodeURIComponent, won't throw any error.\n * If `decodeURIComponent` error happen, just return the original value.\n *\n * @param {String} text\n * @returns {String} URL decode original string.\n * @private\n */\n\n\nfunction safeDecodeURIComponent(text) {\n  try {\n    return decodeURIComponent(text);\n  } catch (e) {\n    return text;\n  }\n}","map":{"version":3,"sources":["/Users/jubi/fullStack/groupProject/0322/xyz.frontend/node_modules/koa-router/lib/layer.js"],"names":["debug","require","pathToRegExp","uri","module","exports","Layer","path","methods","middleware","opts","name","paramNames","stack","Array","isArray","i","length","l","push","toUpperCase","unshift","fn","type","Error","toString","regexp","prefix","prototype","match","test","params","captures","existingParams","len","c","safeDecodeURIComponent","ignoreCaptures","slice","url","options","args","replace","toPath","compile","replaced","call","arguments","tokens","parse","j","some","token","query","search","param","ctx","next","names","map","p","x","indexOf","splice","setPrefix","text","decodeURIComponent","e"],"mappings":"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","sourcesContent":["var debug = require('debug')('koa-router');\nvar pathToRegExp = require('path-to-regexp');\nvar uri = require('urijs');\n\nmodule.exports = Layer;\n\n/**\n * Initialize a new routing Layer with given `method`, `path`, and `middleware`.\n *\n * @param {String|RegExp} path Path string or regular expression.\n * @param {Array} methods Array of HTTP verbs.\n * @param {Array} middleware Layer callback/middleware or series of.\n * @param {Object=} opts\n * @param {String=} opts.name route name\n * @param {String=} opts.sensitive case sensitive (default: false)\n * @param {String=} opts.strict require the trailing slash (default: false)\n * @returns {Layer}\n * @private\n */\n\nfunction Layer(path, methods, middleware, opts) {\n  this.opts = opts || {};\n  this.name = this.opts.name || null;\n  this.methods = [];\n  this.paramNames = [];\n  this.stack = Array.isArray(middleware) ? middleware : [middleware];\n\n  for(var i = 0; i < methods.length; i++) {\n    var l = this.methods.push(methods[i].toUpperCase());\n    if (this.methods[l-1] === 'GET') {\n       this.methods.unshift('HEAD');\n    }\n  }\n\n  // ensure middleware is a function\n  for (var i = 0; i < this.stack.length; i++) {\n    var fn = this.stack[i];\n    var type = (typeof fn);\n    if (type !== 'function') {\n      throw new Error(\n        methods.toString() + \" `\" + (this.opts.name || path) +\"`: `middleware` \"\n        + \"must be a function, not `\" + type + \"`\"\n      );\n    }\n  }\n\n  this.path = path;\n  this.regexp = pathToRegExp(path, this.paramNames, this.opts);\n\n  debug('defined route %s %s', this.methods, this.opts.prefix + this.path);\n};\n\n/**\n * Returns whether request `path` matches route.\n *\n * @param {String} path\n * @returns {Boolean}\n * @private\n */\n\nLayer.prototype.match = function (path) {\n  return this.regexp.test(path);\n};\n\n/**\n * Returns map of URL parameters for given `path` and `paramNames`.\n *\n * @param {String} path\n * @param {Array.<String>} captures\n * @param {Object=} existingParams\n * @returns {Object}\n * @private\n */\n\nLayer.prototype.params = function (path, captures, existingParams) {\n  var params = existingParams || {};\n\n  for (var len = captures.length, i=0; i<len; i++) {\n    if (this.paramNames[i]) {\n      var c = captures[i];\n      params[this.paramNames[i].name] = c ? safeDecodeURIComponent(c) : c;\n    }\n  }\n\n  return params;\n};\n\n/**\n * Returns array of regexp url path captures.\n *\n * @param {String} path\n * @returns {Array.<String>}\n * @private\n */\n\nLayer.prototype.captures = function (path) {\n  if (this.opts.ignoreCaptures) return [];\n  return path.match(this.regexp).slice(1);\n};\n\n/**\n * Generate URL for route using given `params`.\n *\n * @example\n *\n * ```javascript\n * const route = new Layer('/users/:id', ['GET'], fn);\n *\n * route.url({ id: 123 }); // => \"/users/123\"\n * ```\n *\n * @param {Object} params url parameters\n * @returns {String}\n * @private\n */\n\nLayer.prototype.url = function (params, options) {\n  var args = params;\n  var url = this.path.replace(/\\(\\.\\*\\)/g, '');\n  var toPath = pathToRegExp.compile(url);\n  var replaced;\n\n  if (typeof params != 'object') {\n    args = Array.prototype.slice.call(arguments);\n    if (typeof args[args.length - 1] == 'object') {\n      options = args[args.length - 1];\n      args = args.slice(0, args.length - 1);\n    }\n  }\n\n  var tokens = pathToRegExp.parse(url);\n  var replace = {};\n\n  if (args instanceof Array) {\n    for (var len = tokens.length, i=0, j=0; i<len; i++) {\n      if (tokens[i].name) replace[tokens[i].name] = args[j++];\n    }\n  } else if (tokens.some(token => token.name)) {\n    replace = params;\n  } else {\n    options = params;\n  }\n\n  replaced = toPath(replace);\n\n  if (options && options.query) {\n    var replaced = new uri(replaced)\n    replaced.search(options.query);\n    return replaced.toString();\n  }\n\n  return replaced;\n};\n\n/**\n * Run validations on route named parameters.\n *\n * @example\n *\n * ```javascript\n * router\n *   .param('user', function (id, ctx, next) {\n *     ctx.user = users[id];\n *     if (!user) return ctx.status = 404;\n *     next();\n *   })\n *   .get('/users/:user', function (ctx, next) {\n *     ctx.body = ctx.user;\n *   });\n * ```\n *\n * @param {String} param\n * @param {Function} middleware\n * @returns {Layer}\n * @private\n */\n\nLayer.prototype.param = function (param, fn) {\n  var stack = this.stack;\n  var params = this.paramNames;\n  var middleware = function (ctx, next) {\n    return fn.call(this, ctx.params[param], ctx, next);\n  };\n  middleware.param = param;\n\n  var names = params.map(function (p) {\n    return p.name;\n  });\n\n  var x = names.indexOf(param);\n  if (x > -1) {\n    // iterate through the stack, to figure out where to place the handler fn\n    stack.some(function (fn, i) {\n      // param handlers are always first, so when we find an fn w/o a param property, stop here\n      // if the param handler at this part of the stack comes after the one we are adding, stop here\n      if (!fn.param || names.indexOf(fn.param) > x) {\n        // inject this param handler right before the current item\n        stack.splice(i, 0, middleware);\n        return true; // then break the loop\n      }\n    });\n  }\n\n  return this;\n};\n\n/**\n * Prefix route path.\n *\n * @param {String} prefix\n * @returns {Layer}\n * @private\n */\n\nLayer.prototype.setPrefix = function (prefix) {\n  if (this.path) {\n    this.path = prefix + this.path;\n    this.paramNames = [];\n    this.regexp = pathToRegExp(this.path, this.paramNames, this.opts);\n  }\n\n  return this;\n};\n\n/**\n * Safe decodeURIComponent, won't throw any error.\n * If `decodeURIComponent` error happen, just return the original value.\n *\n * @param {String} text\n * @returns {String} URL decode original string.\n * @private\n */\n\nfunction safeDecodeURIComponent(text) {\n  try {\n    return decodeURIComponent(text);\n  } catch (e) {\n    return text;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}